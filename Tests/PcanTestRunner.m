// This script runs QPDIndec and checks the generated p-canonical basis with a table of p-canonical bases.
// The table should be generated by configuring and running PcanTestGenerator.m, which uses the pDIndec code, and
// will generate a file named something like "pcan-A~2-5-upto-30-0-0". This test can then be run using
//    magma filename:=pcan-A~2-5-upto-30-0-0 limit:=200 RunPcanTest.m
// which will test at most 200 basis elements, going up in increasing lex order. You can also pass a profiling
// filename
//    profile:=prof1-
// for example, which will run the test with the profiler on, and dump profiling information to prof1-.html
// Passing the argument
//    maxrat:=true
// will cause the maximum rational number appearing in matrices associated to the indecomposable to be printed.
// The argument
//    scalehoms:=true
// will do an ad-hoc rescaling of each light leaf hom to try to balance numerators and denominators.

if assigned batch then SetQuitOnError(true); else SetDebugOnError(true); end if;

// Parse arguments.
error if not assigned filename, "Need to provide a filename argument.";

limit := assigned limit
    select StringToInteger(limit)
    else 0;

maxrat := assigned maxrat select eval maxrat else false;
assert Type(maxrat) eq BoolElt;

scalehoms := assigned scalehoms select eval scalehoms else false;
assert Type(scalehoms) eq BoolElt;

AttachSpec("ASLoc.spec");
SetColumns(0);
SetAssertions(1);


if assigned profile then
    SetProfile(true);
end if;

r := eval Read(filename);

// Can only deal with the affine case right now.
affroots := {1 .. Nrows(r`cartan)} diff SequenceToSet(r`sphsubset);
assert #affroots eq 1;
affroot := Rep(affroots);

W := CoxeterGroup(GrpFPCox, r`cartan);
B := BSAntiSpherical(r`cartan, W, affroot);
HAlg := IHeckeAlgebra(W);
ASMod := IHeckeASMod(W, B`I);
aC := CanonicalBasis(ASMod);
pcans := DeserialisePcanIntoAS2(ASMod, r);

printf "Read %o p-canonical basis elements for %o, p = %o\n", #pcans, CartanName(r`cartan), r`char;

if limit eq 0 then
    limit := #pcans;
else
    limit := Min(#pcans, limit);
end if;

printf "Will test %o p-canonical basis elements\n", limit;

indecs := AssociativeArray();
for i -> alcove in Sort(Setseq(Keys(pcans)))[1..limit] do
    param := EltToParam(alcove);
    printf "Checking alcove %o/%o: %o\n", i, limit, param;
    indecs[alcove] := calcQIndec(B, indecs, alcove, r`char, HAlg, ASMod);

    error if indecs[alcove]`character ne pcans[alcove],
        "p-canonical basis elements do not agree for", alcove,
        "Expected:", pcans[alcove],
        "Recieved:", indecs[alcove]`character;

    if maxrat then
        print "Maximum numerator or denominator:", MaximumNumeratorOrDenominator(indecs[alcove]);
    end if;
end for;

printf "Checked %o p-canonical basis elements, all correct.\n", limit;


if assigned profile then
    G := ProfileGraph();
    ProfileHTMLOutput(G, profile);
    printf "Profiling data written to %o.html\n", profile;
end if;

if assigned batch then quit; end if;
