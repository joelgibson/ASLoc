// Let (W, S) be a Coxeter system. The FreeBSCat corresponding to (W, S) is the free monoidal category
// generated by the objects S, and the generating morphisms of the Bott-Samelson Diagrammatic Hecke
// category: this includes the two dots (unit and counit), the two trivalent vertices (multiplication
// and comultiplication), the cups and caps, and the 2mst-valent vertices. We do not enrich this category
// over any ring. Note also the cups and caps are not necessary to include as generators, but they make
// some things easier.
//
// Objects of this category are represented by sequences in the generators S, and morphisms are made of
// vertical compositions of (horizontal compositions of generating morphisms). A generating morphism is
// determined by its source and target, if they are unequal the source and target are one of:
//   unit: [] -> [s]
//   counit: [s] -> []
//   cup: [] -> [s, s]
//   cap: [s, s] -> []
//   mult: [s, s] -> [s]
//   comult: [s] -> [s, s]
//   braid: [s, t, ...] -> [t, s, ...]
// If the source and target are equal (eg [] -> [], [s] -> [s], [s, t] -> [s, t], etc) then the generating
// morphism is an identity morphism.
//
// The only data required to define this category is the underlying Coxeter system.
declare type BSFreeCat[BSFreeMor];
declare attributes BSFreeCat:
    CoxeterGroup;  // The Coxeter group, a GrpFPCox.

intrinsic Print(BSF::BSFreeCat)
{}
    printf "Free Bott-Samelson category on %o", BSF`CoxeterGroup;
end intrinsic;

intrinsic CoxeterGroup(BSF::BSFreeCat) -> GrpFPCox
{Return the underlying Coxeter system.}
    return BSF`CoxeterGroup;
end intrinsic;

intrinsic CreateBSFreeCat(W::GrpFPCox) -> BSFreeCat
{Create a new Bott-Samelson free diagramatic category.}
    BSF := New(BSFreeCat);
    BSF`CoxeterGroup := W;
    return BSF;
end intrinsic;

intrinsic 'eq'(A::BSFreeCat, B::BSFreeCat) -> BoolElt
{}
    return CoxeterGroup(A) eq CoxeterGroup(B);
end intrinsic;


declare type BSFreeMor;
declare attributes BSFreeMor:
    Parent,     // (W, S) a Coxeter system
    Domain,     // [RngIntElt] of elements of S
    Codomain,   // [RngIntElt] of elements of S
    Rows;       // A list of rows, with each row being a list of tuples

intrinsic Print(mor::BSFreeMor)
{}
    printf "Free Bott-Samelson morphism %o -> %o", mor`Domain, mor`Codomain;
end intrinsic;

intrinsic Parent(mor::BSFreeMor) -> BSFreeCat
{}
    return mor`Parent;
end intrinsic;

intrinsic Domain(mor::BSFreeMor) -> SeqEnum[RngIntElt]
{}
    return mor`Domain;
end intrinsic;

intrinsic Codomain(mor::BSFreeMor) -> SeqEnum[RngIntElt]
{}
    return mor`Codomain;
end intrinsic;

intrinsic Rows(mor::BSFreeMor) -> SeqEnum[SeqEnum[Tup]]
{}
    return mor`Rows;
end intrinsic;

intrinsic BSFreeMorConstruct(BSF::BSFreeCat, domain::[RngIntElt], codomain::[RngIntElt], rows::SeqEnum[SeqEnum[Tup]]) -> BSFreeMor
{Create a new BSFreeMorphism.}
    // Check that domains and codomains match between adjacent rows.
    prevobj := domain;
    for i := #rows to 1 by -1 do
        bottom := &cat[pair[1] : pair in rows[i]];
        require prevobj eq bottom: "Domains", prevobj, "and", bottom, "do not compose";
        prevobj := &cat[pair[2] : pair in rows[i]];
    end for;
    require prevobj eq codomain: "Domains", prevobj, "and", codomain, "do not compose";

    mor := New(BSFreeMor);
    mor`Parent := BSF;
    mor`Domain := domain;
    mor`Codomain := codomain;
    mor`Rows := rows;
    return mor;
end intrinsic;

intrinsic Identity(BSF::BSFreeCat, word::[RngIntElt]) -> BSFreeMor
{Return the identity morphism on the object.}
    return BSFreeMorConstruct(BSF, word, word, []);
end intrinsic;

intrinsic 'cat'(mor::BSFreeMor, word::[RngIntElt]) -> BSFreeMor
{Tensor product with an identity morphism on the right. We could just append [word] -> [word] to
 every row, but instead we merge it in if the row already ends with an identity morphism.}
    return BSFreeMorConstruct(
        mor`Parent,
        mor`Domain cat word,
        mor`Codomain cat word,
        [row[#row][1] eq row[#row][2]
            select Append(row[1..#row-1], <row[#row][1] cat word, row[#row][2] cat word>)
              else Append(row, <word, word>)
            : row in mor`Rows]
    );
end intrinsic;

intrinsic 'cat'(left::BSFreeMor, right::BSFreeMor) -> BSFreeMor
{Tensor product (i.e. horizontal composition) of morphisms, using (f ⊗ g) = (id ⊗ g) o (f ⊗ id).}
    require left`Parent eq right`Parent: "Parent categories must be equal";
    return BSFreeMorConstruct(
        left`Parent,
        left`Domain cat right`Domain,
        left`Codomain cat right`Codomain,
        [[<left`Codomain, left`Codomain>] cat row : row in right`Rows]
        cat
        [row cat [<right`Domain, right`Domain>] : row in left`Rows]
    );
end intrinsic;

intrinsic 'cat'(left::BSFreeMor, right::[RngIntElt]) -> BSFreeMor
{Tensor product with an identity morphism on the right.}
    return left cat Identity(Parent(left), right);
end intrinsic;

intrinsic 'cat'(left::[RngIntElt], right::BSFreeMor) -> BSFreeMor
{Tensor product with an identity morphism on the left.}
    return Identity(Parent(right), left) cat right;
end intrinsic;


intrinsic '*'(top::BSFreeMor, bot::BSFreeMor) -> BSFreeMor
{Vertical composition top o bot.}
    require top`Parent eq bot`Parent: "Cannot compose: different parent categories";
    require top`Domain eq bot`Codomain: "Cannot compose: domain and codomain mismatch";
    return BSFreeMorConstruct(top`Parent, bot`Domain, top`Codomain, top`Rows cat bot`Rows);
end intrinsic;

intrinsic VerticalFlip(mor::BSFreeMor) -> BSFreeMor
{Involution turning a morphism upside-down.}
    return BSFreeMorConstruct(
        Parent(mor), Codomain(mor), Domain(mor),
        [[<pair[2], pair[1]> : pair in row] : row in Reverse(row)]);
end intrinsic;

intrinsic Counit(BSF::BSFreeCat, s::RngIntElt) -> BSMor
{The dot morphism Bs -> 1.}
    return BSFreeMorConstruct(BSF, [s], [], [[<[s], []>]]);
end intrinsic;

intrinsic Unit(BSF::BSFreeCat, s::RngIntElt) -> BSMor
{The dot morphism 1 -> Bs.}
    return BSFreeMorConstruct(BSF, [], [s], [[<[], [s]>]]);
end intrinsic

intrinsic Comult(BSF::BSFreeCat, s::RngIntElt) -> BSMor
{The trivalent vertex Bs -> Bs Bs.}
    return BSFreeMorConstruct(BSF, [s], [s, s], [[<[s], [s, s]>]]);
end intrinsic;

intrinsic Mult(BSF::BSFreeCat, s::RngIntElt) -> BSMor
{The trivalent vertex Bs Bs -> Bs.}
    return BSFreeMorConstruct(BSF, [s, s], [s], [[<[s, s], [s]>]]);
end intrinsic;

intrinsic Cap(BSF::BSFreeCat, s::RngIntElt) -> BSMor
{The cap Bs Bs -> 1.}
    return BSFreeMorConstruct(BSF, [s, s], [], [[<[s, s], []>]]);
end intrinsic;

intrinsic Cup(BSF::BSFreeCat, s::RngIntElt) -> BSMor
{The cup 1 -> Bs Bs.}
    return BSFreeMorConstruct(BSF, [], [s, s], [[<[], [s, s]>]]);
end intrinsic;

intrinsic Braid(BSF::BSFreeCat, s::RngIntElt, t::RngIntElt) -> BSMor
{The 2m_st-valent vertex Bs Bt ... -> Bt Bs ...}
    mst := CoxeterMatrix(CoxeterGroup(BSF))[s, t];
    require 2 le mst: s, t, "do not have finite order";
    st := [i mod 2 eq 1 select s else t : i in [1..mst]];
    ts := [i mod 2 eq 1 select t else s : i in [1..mst]];
    return BSFreeMorConstruct(BSF, st, ts, [[<st, ts>]]);
end intrinsic;

intrinsic SVG(mor::BSFreeMor) -> MonStgElt
{Return an SVG representation of the morphism.}
    H := 50;    // Horizontal spacing
    V := 50;    // Vertical spacing

    paths := [];
    for i -> row in mor`Rows do
        rownum := i - 1;
        botpos := 0;
        toppos := 0;
        for gen in row do
            src := gen[1];
            dst := gen[2];

            print src, dst;

            // Identity morphism
            if src eq dst then
                // Cubic Bezier
                paths +:= [*
                    "M", botpos*H, rownum*V,
                    "C", botpos*H, (rownum + 0.2)*V,
                    ",", toppos*H, (rownum + 0.8)*V,
                    ",", toppos*H, (rownum + 1)*V
                *];
            end if;
        end for;
    end for;

    width := 100;
    height := 100;
    return &cat&cat[
        [Sprintf("<svg width=\"%o\" height=\"%o\" xmlns=\"http://www.w3.org/2000/svg\"", width, height)],
        ["<g transform=\"translate(10, 10)\">"],
        [Sprintf("<path d=\"%o\" stroke=\"black\"/>", &cat[Sprintf("%o", x) : x in path]) : path in paths],
        ["</g>"],
        ["</svg>"]
    ];
end intrinsic;
